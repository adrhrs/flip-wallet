// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package usecase

import (
	"context"
	"github.com/flip-clean/models"
	"sync"
)

// Ensure, that UserUsecaseMock does implement UserUsecase.
// If this is not the case, regenerate this file with moq.
var _ UserUsecase = &UserUsecaseMock{}

// UserUsecaseMock is a mock implementation of UserUsecase.
//
// 	func TestSomethingThatUsesUserUsecase(t *testing.T) {
//
// 		// make and configure a mocked UserUsecase
// 		mockedUserUsecase := &UserUsecaseMock{
// 			GetUserInfoFunc: func(ctx context.Context) (string, string, error) {
// 				panic("mock out the GetUserInfo method")
// 			},
// 			IsUserExistFunc: func(username string) bool {
// 				panic("mock out the IsUserExist method")
// 			},
// 			RegisterUserFunc: func(ctx context.Context, param models.UserRegistrationPayload) (string, error) {
// 				panic("mock out the RegisterUser method")
// 			},
// 		}
//
// 		// use mockedUserUsecase in code that requires UserUsecase
// 		// and then make assertions.
//
// 	}
type UserUsecaseMock struct {
	// GetUserInfoFunc mocks the GetUserInfo method.
	GetUserInfoFunc func(ctx context.Context) (string, string, error)

	// IsUserExistFunc mocks the IsUserExist method.
	IsUserExistFunc func(username string) bool

	// RegisterUserFunc mocks the RegisterUser method.
	RegisterUserFunc func(ctx context.Context, param models.UserRegistrationPayload) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetUserInfo holds details about calls to the GetUserInfo method.
		GetUserInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// IsUserExist holds details about calls to the IsUserExist method.
		IsUserExist []struct {
			// Username is the username argument value.
			Username string
		}
		// RegisterUser holds details about calls to the RegisterUser method.
		RegisterUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Param is the param argument value.
			Param models.UserRegistrationPayload
		}
	}
	lockGetUserInfo  sync.RWMutex
	lockIsUserExist  sync.RWMutex
	lockRegisterUser sync.RWMutex
}

// GetUserInfo calls GetUserInfoFunc.
func (mock *UserUsecaseMock) GetUserInfo(ctx context.Context) (string, string, error) {
	if mock.GetUserInfoFunc == nil {
		panic("UserUsecaseMock.GetUserInfoFunc: method is nil but UserUsecase.GetUserInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetUserInfo.Lock()
	mock.calls.GetUserInfo = append(mock.calls.GetUserInfo, callInfo)
	mock.lockGetUserInfo.Unlock()
	return mock.GetUserInfoFunc(ctx)
}

// GetUserInfoCalls gets all the calls that were made to GetUserInfo.
// Check the length with:
//     len(mockedUserUsecase.GetUserInfoCalls())
func (mock *UserUsecaseMock) GetUserInfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetUserInfo.RLock()
	calls = mock.calls.GetUserInfo
	mock.lockGetUserInfo.RUnlock()
	return calls
}

// IsUserExist calls IsUserExistFunc.
func (mock *UserUsecaseMock) IsUserExist(username string) bool {
	if mock.IsUserExistFunc == nil {
		panic("UserUsecaseMock.IsUserExistFunc: method is nil but UserUsecase.IsUserExist was just called")
	}
	callInfo := struct {
		Username string
	}{
		Username: username,
	}
	mock.lockIsUserExist.Lock()
	mock.calls.IsUserExist = append(mock.calls.IsUserExist, callInfo)
	mock.lockIsUserExist.Unlock()
	return mock.IsUserExistFunc(username)
}

// IsUserExistCalls gets all the calls that were made to IsUserExist.
// Check the length with:
//     len(mockedUserUsecase.IsUserExistCalls())
func (mock *UserUsecaseMock) IsUserExistCalls() []struct {
	Username string
} {
	var calls []struct {
		Username string
	}
	mock.lockIsUserExist.RLock()
	calls = mock.calls.IsUserExist
	mock.lockIsUserExist.RUnlock()
	return calls
}

// RegisterUser calls RegisterUserFunc.
func (mock *UserUsecaseMock) RegisterUser(ctx context.Context, param models.UserRegistrationPayload) (string, error) {
	if mock.RegisterUserFunc == nil {
		panic("UserUsecaseMock.RegisterUserFunc: method is nil but UserUsecase.RegisterUser was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Param models.UserRegistrationPayload
	}{
		Ctx:   ctx,
		Param: param,
	}
	mock.lockRegisterUser.Lock()
	mock.calls.RegisterUser = append(mock.calls.RegisterUser, callInfo)
	mock.lockRegisterUser.Unlock()
	return mock.RegisterUserFunc(ctx, param)
}

// RegisterUserCalls gets all the calls that were made to RegisterUser.
// Check the length with:
//     len(mockedUserUsecase.RegisterUserCalls())
func (mock *UserUsecaseMock) RegisterUserCalls() []struct {
	Ctx   context.Context
	Param models.UserRegistrationPayload
} {
	var calls []struct {
		Ctx   context.Context
		Param models.UserRegistrationPayload
	}
	mock.lockRegisterUser.RLock()
	calls = mock.calls.RegisterUser
	mock.lockRegisterUser.RUnlock()
	return calls
}
